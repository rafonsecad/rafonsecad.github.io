---
title: CVE-2024-38828 POC
author: rafonsecad
date: 2025-05-19
categories: [PoC]
tags: [spring boot, java]
---

## Introduction

This is a poc for the security issue found in spring last year. It's really simple and fun to research. Quoting the official description of the [bug](https://spring.io/security/cve-2024-38828):

> Spring MVC controller methods with an @RequestBody byte[] method parameter are vulnerable to a DoS attack.

## Analysis

The affected spring framework version is 5.3.x, this version corresponds a spring boot version [2.7](https://github.com/spring-projects/spring-boot/releases/tag/v2.7.18). Let's start by creating a spring boot app (version 2.7.18) with the following endpoint

```java
@RestController
public class DemoController {

    @PostMapping("/api/file")
    ResponseEntity<Void> endpoint(@RequestBody byte[] file) {
        System.out.println(new String(file));
        return ResponseEntity.ok().build();
    }
}
```

then let's remember how Message converters work. In spring framework, a message converter tries to cast the http raw body to the requested type, in this case since we want to represent the body as a `byte[]`, the corresponding message converter is ByteArrayHttpMessageConverter

```java
@Override
public byte[] readInternal(Class<? extends byte[]> clazz, HttpInputMessage inputMessage) 
     throws IOException {
	long contentLength = inputMessage.getHeaders().getContentLength();
	ByteArrayOutputStream bos =
			new ByteArrayOutputStream(contentLength >= 0 ? (int) contentLength : 
                                                                   StreamUtils.BUFFER_SIZE); //4096
	StreamUtils.copy(inputMessage.getBody(), bos);
	return bos.toByteArray();
}
```

Here we can spot the bug. To recognize it, let's take a quick look at the [ByteArrayOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ByteArrayOutputStream.html#%3Cinit%3E(int)) documentation

> `public ByteArrayOutputStream (int size)`
>
> Creates a new ByteArrayOutputStream, with a buffer capacity of the specified size, in bytes.

so inside the method `readInternal` the variable `bos` is created with a buffer capacity defined by `Content-Length`, which is a header that the user (or an attacker) can modify.

## Exploitation

By crafting a request with a huge `Content-Length` will make the app to waste memory that otherwise could be used for other operations and it could ultimately cause a denial of service. A simple request like below can force the app to reserve 2GB of memory.

```bash
curl -X POST http://localhost:8080/api/file -d 'lol' -H "Content-Type: application/json" \
     -H "Content-Length: 2000000000"
```

ByteArrayOutputStream accepts an `int` as argument, so the maximum theorical value is `2,147,483,647`, but in reality, creating such buffer depends on the heap space configured for the JVM. If the heap space is not enough, the JVM will throw an `OutOfMemoryError` Exception and the request will be rejected.

After the payload is sent and the JVM reserved the memory successfully, the application waits for more information since it's expecting the body length to match what `Content-Length` says. If no more information is sent then the application will trigger a `SocketTimeOutException`, by default such timeout is 1 minute in **Tomcat**, 30 seconds in **jetty**, and **undertow** doesn't have a timeout configured.

In the tests I made, setting `Content-Type` as `application/x-www-form-urlencoded` will make **Tomcat** libraries to parse the body parameters and it will get stuck until `SocketTimeOutException` triggers without going trough `ByteArrayHttpMessageConverter`, that's why I set `Content-Type` as `application/json` and worked in all three application servers. Others content types might work as well.

## Affected versions

The official report says that besides spring framework version 5.3, older and unsupported version might be affected. The last [commit](https://github.com/spring-projects/spring-framework/commit/dd7f54c3c06ba4da673634d9dc3c456fb343cb67#diff-f25645369b46deba08338d6a57b8fd59c749d7766d66b8fc6d58bda2e9b1aa31) that touched this part of the code dates back from March 2014 but the bug seems to be already there. So it's possible this vulnerability has been present way before version 4.x

## Mitigation

The official report recommends changing the parameter type from `byte[]` to `InputStream` if a spring framework update is not possible. To make this work, be aware that using `InputStream` as a [parameter](https://github.com/spring-projects/spring-framework/issues/14119) doesn't need `@RequestBody` annotation, after that change our initial endpoint would look like this

```java
@RestController
public class DemoController {

    @PostMapping("/api/file")
    ResponseEntity<Void> endpoint(InputStream file) throws Exception {
        System.out.println(new String(file.readAllBytes()));
        return ResponseEntity.ok().build();
    }
}
```

